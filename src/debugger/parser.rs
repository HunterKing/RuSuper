use std::fmt::{self, Debug};

use crate::emu::VirtualMachine;

use super::{DebuggerState, TokenSeparator};

/// parser.rs
/// # About this file
/// This file contains the functionality for the debugger to parse arguments from the user into lists of tokens.
/// The general flow is as follows:
///     1. collect_args() takes a set of arguments as a list of strings which are split by spaces, and then encodes them as a list of their token types.
///     2. collect_tags() takes a list of tokens and converts Value() to Tag() where an invalid numeric value is found.
///     3. validate_tag_offsets() takes a list of tokens and converts Tag()s back into Value()s when they already exist.
///     4. compute_address_from_args() takes a list of tokens, and computes the finalized address by calling apply_modifiers().
///         * apply_modifiers() takes a list of tokens and applies all of the modifiers to values where necessary.

/**************************************** Struct and Type definitions ***************************************************/

/// Error to generate when a bad argument is passed to the debugger.
#[derive(Debug, Clone)]
pub struct InvalidDbgArgError {
    value: String,
}

impl fmt::Display for InvalidDbgArgError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "{}", self.value) }
}

impl From<&str> for InvalidDbgArgError {
    fn from(value: &str) -> Self {
        Self {
            value: value.to_string().clone(),
        }
    }
}

impl From<String> for InvalidDbgArgError {
    fn from(value: String) -> Self {
        Self {
            value: value.clone(),
        }
    }
}

/// Helpful operators for translating Strings -> Values
pub trait HexOperators {
    fn is_hex(&self) -> bool;
    fn is_decimal(&self) -> bool;
    fn to_hex(&self) -> Result<usize, InvalidDbgArgError>;
}

impl HexOperators for String {
    /// Check if a value is constructed only from hex digits.
    /// # Parameters:
    ///     - `self`
    /// # Returns:
    ///     - `true`    if the string was a contained hex value,
    ///     - `false`   if the string was not a hex value.
    fn is_hex(&self) -> bool {
        for char in self.chars() {
            if !char.is_digit(16) {
                return false;
            }
        }
        return true;
    }

    /// Check if a value is constructed only from decimal digits.
    /// # Parameters:
    ///     - `self`
    /// # Returns:
    ///     - `true`    if the string consists of only decimal digits.
    ///     - `false`   if the string was not only decimal digits.
    fn is_decimal(&self) -> bool {
        for char in self.chars() {
            if !char.is_digit(10) {
                return false;
            }
        }
        return true;
    }

    fn to_hex(&self) -> Result<usize, InvalidDbgArgError> { string_to_hex(self) }
}

impl HexOperators for &str {
    fn is_hex(&self) -> bool {
        for char in self.chars() {
            if !char.is_digit(16) {
                return false;
            }
        }
        return true;
    }

    fn is_decimal(&self) -> bool {
        for char in self.chars() {
            if !char.is_digit(10) {
                return false;
            }
        }
        return true;
    }

    fn to_hex(&self) -> Result<usize, InvalidDbgArgError> { string_to_hex(self) }
}

trait HexToString {
    fn to_hex_string(&self) -> String;
}

impl HexToString for usize {
    fn to_hex_string(&self) -> String {
        format!("{:#08X}", self)
            .strip_prefix("0x")
            .unwrap()
            .to_string()
    }
}

pub type DebugTokenStream = Vec<TokenSeparator>;

/// Helper functions for the token streams generated by the parser.
pub trait TokenStreamHelpers {
    fn contains_tag(&self) -> bool;
    fn _modifies_tag(&self) -> bool;
    fn _next_tag(&self, start_index: usize) -> Option<usize>;
    fn get_tag_names(&self) -> Option<Vec<String>>;
}

impl TokenStreamHelpers for DebugTokenStream {
    /// Checks if there is a Tag(tagname) at any placement in the list.
    /// Parameters:
    ///     - `self`:   List of tokens
    /// Returns:
    ///     - `true`:   If the list contains a tag.
    ///     - `false`:  If the list does not contain a tag.
    fn contains_tag(&self) -> bool {
        for token in self {
            if let TokenSeparator::Tag(_value) = token {
                return true;
            }
        }
        return false;
    }

    /// Checks if there is an offset immediately applied to a tag at any point in the list.
    /// e.g. tagname + $XXX or $XXX + tagname
    /// Parameters:
    ///     - `self`: List of tokens
    /// Returns:
    ///     - `true`:   If there is an offset applied to a tag.
    ///     - `false`:  If there are no offsets applied directly to a tag.
    fn _modifies_tag(&self) -> bool {
        let mut last_token: Option<TokenSeparator> = None;
        for ref token in self {
            match token {
                TokenSeparator::Tag(_) => {
                    if let Some(TokenSeparator::Offset) = last_token {
                        return true;
                    }
                }
                TokenSeparator::Offset => {
                    if let Some(TokenSeparator::Tag(_)) = last_token {
                        return true;
                    }
                }
                _ => (),
            }
            last_token = Some((*token).clone());
        }
        return false;
    }

    /// Return the index of the next tag in the list.
    /// # Parameters:
    ///     - `self`:           List to parse
    ///     - `start_index`:    Where to begin parsing from to find tag.
    /// # Returns:
    ///     - `None`:           If no tags exist past this index.
    ///     - `Some(index)`:    The index of the next tag in the list.
    fn _next_tag(&self, start_index: usize) -> Option<usize> {
        for (index, token) in self[start_index..].iter().enumerate() {
            match token {
                TokenSeparator::Tag(_) => {
                    return Some(index);
                }
                _ => (),
            }
        }
        None
    }

    /// Get a list of all of the tag names in the stream, if possible.
    /// # Parameters:
    ///     - `self`:       List to parse.
    /// # Returns:
    ///     - `Some(Vec<String>)`:  List of all of the tag names where possible,
    ///     - `None`:               If the list contained no tags.
    fn get_tag_names(&self) -> Option<Vec<String>> {
        let mut tags: Vec<String> = vec![];
        for token in self {
            match token {
                TokenSeparator::Tag(name) => {
                    tags.push(name.clone());
                }
                _ => (),
            }
        }
        if tags.len() > 0 {
            Some(tags)
        }
        else {
            None
        }
    }
}

/**************************************** File Scope Functions **********************************************************/

/// Collect arguments from a set of strings input by the user.
/// # Parameters:
///     - `argvec`: List of arguments passed by the user to the function,
///     - `debug`:  Debugger state which contains the table of tags where needed.
/// # Returns:
///     - `Ok(Vec<TokenSeparator>)`:    List of tokens, where tags inside are represented as Value(tagname).
///     - `Err(InvalidDbgArgError)`:    Error if the user passed in an invalid argument.
fn collect_args(argvec: Vec<&str>) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut delimiters: DebugTokenStream = vec![];
    let mut value_buffer: String = String::new();

    let args = argvec.join(" ");
    if args.len() > 0 {
        for current_char in args.chars() {
            let current_token = TokenSeparator::from(current_char.to_string().as_str());
            match current_token {
                // If a separator is found, clear the buffer of other characters and then push on the sepatator.
                TokenSeparator::HexValue | TokenSeparator::Offset => {
                    if value_buffer.len() > 0 {
                        delimiters.push(TokenSeparator::Value(value_buffer));
                        value_buffer = String::new();
                    }
                    delimiters.push(current_token);
                }

                // If we found a divider, just clear the buffer.
                TokenSeparator::Divider => {
                    if value_buffer.len() > 0 {
                        delimiters.push(TokenSeparator::Value(value_buffer));
                        value_buffer = String::new();
                    }
                }

                // If it is not a delimiting character, push it onto the value buffer for now.
                TokenSeparator::Invalid => {
                    value_buffer.push(current_char);
                }
                _ => (),
            }
        }
    }
    else {
        return Err(InvalidDbgArgError::from("Length of args passed was 0"));
    }
    // If there's anything left in the value buffer at the end throw it on.
    if value_buffer.len() > 0 {
        delimiters.push(TokenSeparator::Value(value_buffer));
    }
    Ok(delimiters)
}

/// Iterate through a vector of TokenSeparator, and for each TokenSeparator::Value, discern if it is a tag or a number.
/// A tag is any value which is not parseable as a decimal or hexadecimal value,
///     or a potential hexadecimal value which is not led by a TokenSeparator::HexValue.
/// # Parameters:
///     - `tokens`:         A list of tokens to digest, where all tags are represented as TokenSeparator::Value(tagname).
/// # Returns:
///     - A list of tokens, with TokenSeparator::Values, where all tags are represented as TokenSeparator::Tag(tagname).
fn collect_tags(tokens: DebugTokenStream) -> DebugTokenStream {
    let mut last_token: Option<TokenSeparator> = None;
    let mut new_vec: DebugTokenStream = vec![];

    for token in tokens {
        match token {
            TokenSeparator::Value(ref data) => {
                // If the value is strictly numeric, just push it on as a value.
                if data.is_decimal() {
                    new_vec.push(TokenSeparator::Value(data.to_string()));
                }
                // If the value is in hex, check that the modifier was found to be present, or else we are looking at a tag name.
                else if data.is_hex() {
                    if let Some(TokenSeparator::HexValue) = last_token {
                        new_vec.push(TokenSeparator::Value(data.to_string()));
                    }
                    else {
                        new_vec.push(TokenSeparator::Tag(data.to_string()));
                    }
                }
                // Otherwise put it on as a tag.
                else {
                    new_vec.push(TokenSeparator::Tag(data.to_string()));
                }
            }
            _ => new_vec.push(token.clone()),
        }
        last_token = Some(token);
    }

    new_vec
}

/// Parse a full list of arguments and check that if any tags within are being modified by an offset.
///     If they are, they must exist at the time we are checking, or else we have been handed a bad argument.
/// Parameters:
///     - `tokens`:     Mutable list of TokenSeparator tokens, where Tags are represented as Tag(tagname).
///     - `debug`:      Debugger with the list of tags to match from.
/// Returns:
///     - `Ok(Vec<TokenSeparator>)`:    A new list of tokens, with the tags represented as Value(*tagname) where possible.
///     - `Err(InvalidDbgArgError)`:    An error informing the user the first tag which is invalid.
fn validate_tags(
    mut tokens: DebugTokenStream, debug: &DebuggerState,
) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut last_token: Option<TokenSeparator> = None;
    let mut tag_as_value_stack: DebugTokenStream = vec![];

    // Push each of the values off of token onto the new tag_as_value_stack.
    while let Some(curr_token) = tokens.pop() {
        match curr_token {
            // When a tag is found, try to dereference it.
            TokenSeparator::Tag(ref tagname) => {
                // If it was able to be dereferenced, push it on as it's computed value.
                if let Some(value) = debug.tags.get(tagname) {
                    tag_as_value_stack
                        .push(TokenSeparator::Value((*value.to_hex_string()).to_string()));
                    // All values stored in the hash map will be parsed coming out as hex.
                    tag_as_value_stack.push(TokenSeparator::HexValue);
                }
                // If not, check if the last token was an Offset.
                else {
                    // If it was, then print an error, because the user is trying to perform arithmetic with an undefined value.
                    if let Some(TokenSeparator::Offset) = last_token {
                        return Err(InvalidDbgArgError::from(format!("Attempting to perform arithmetic with a tag which is not yet defined: {}", tagname)));
                    }
                    // Otherwise, insert it to the front of the stack, so that it can be read as a result of the modifications right
                    else {
                        tag_as_value_stack.insert(0, curr_token.clone());
                    }
                }
            }

            // When an offset is found, check if the last item was a tag.
            TokenSeparator::Offset => {
                // If it was, then try to deref it.
                if let Some(TokenSeparator::Tag(tagname)) = last_token {
                    // If it can be dereferenced, then it will have already been put on the stack by the Tag case, so just push the Offset on.
                    if let Some(_value) = debug.tags.get(&tagname) {
                        tag_as_value_stack.push(TokenSeparator::Offset);
                    }
                    // If it can't be dereferenced, then print an error, because the user is trying to perform arithmetic with an undefined value.
                    else {
                        return Err(InvalidDbgArgError::from(format!("Attempting to perform arithmetic with a tag which is not yet defined: {}", tagname)));
                    }
                }
                // If it wasn't a tag, just push this on and proceed as normal.
                else {
                    tag_as_value_stack.push(TokenSeparator::Offset);
                }
            }

            // Any other operator doesn't have much bearing on our tag, so just leave them as they are.
            _ => {
                tag_as_value_stack.push(curr_token.clone());
            }
        }
        last_token = Some(curr_token);
    }


    // Reverse the stack back to the proper order.
    let mut result_tokens: DebugTokenStream = vec![];
    while let Some(token) = tag_as_value_stack.pop() {
        result_tokens.push(token);
    }

    Ok(result_tokens)
}

/// Take in a list of TokenSeparator, apply the modifiers to the values as desired, and spit out the resultant value.
/// # Parameters:
///     - `modifiers`:      List of TokenSeparator containing the modifiers to apply.
///     - `vm`:             Virtual Machine, in case the resultant value is an offset from the current PC.
///     - `base_addr`:      Base address to operate upon. If `None`, use the PC as the base address.
///     - `value`:          Target value to digest, either a tag or a numeric value.
/// # Returns:
///     - `Ok(value)`:                  The computed address value,
///     - `Err(InvalidDbgArgError)`:     If any of the arguments passed to this function were mangled.
fn apply_modifiers(
    modifiers: &mut DebugTokenStream, vm: &VirtualMachine, base_addr: Option<usize>, value: String,
) -> Result<usize, InvalidDbgArgError> {
    let mut scratch_value: usize = 0;
    if value.is_decimal() || value.is_hex() {
        // If the number is decimal go ahead and store the decimal representation into the scratch value.
        if value.is_decimal() {
            scratch_value = value.parse::<usize>().unwrap();
        }

        // Digest any modifiers found.
        if modifiers.len() > 0 {
            // Move right to left an apply the modifiers to the value.
            while let Some(ref modi) = modifiers.pop() {
                match *modi {
                    // If the value is a hex value, convert it to hex.
                    TokenSeparator::HexValue => {
                        scratch_value = value.to_hex()?;
                    }

                    // If there is an offset, do the math.
                    TokenSeparator::Offset => {
                        match base_addr {
                            // If there is some base address to operate on, add the scratch value to it.
                            Some(addr_value) => {
                                scratch_value = addr_value + scratch_value;
                            }
                            // If the address is none, the offset is relative to PC.
                            None => {
                                scratch_value = vm.cpu.get_pc() + scratch_value;
                            }
                        }
                    }
                    _ => (),
                }
            }
        }
    }
    Ok(scratch_value)
}

/// Take a composed token list and compute a finalized address value.
/// Parameters:
///     - `args`: Arguments passed to the command, as a vector of TokenSeparator.
///     - `vm`:     Virtual machine to access memory or program counter from.
/// Returns:
///     - `address`: A fully computed address.
fn compute_address_from_args(
    args: &DebugTokenStream, debug: &DebuggerState, vm: &VirtualMachine,
) -> Result<usize, InvalidDbgArgError> {
    let mut address: Option<usize> = None;
    let mut modifiers: Vec<TokenSeparator> = vec![];
    let mut last_value: Option<String> = None;
    let mut operator_found: bool = true;

    let mut deref_args = args.clone();
    if args.contains_tag() {
        match validate_tags(deref_args, &debug) {
            Ok(tokens) => {
                // If the tokens still contain a tag, return an error because the value can't be calculated.
                if tokens.contains_tag() {
                    return Err(InvalidDbgArgError::from(
                        "Value contained a tag which could not be dereferenced",
                    ));
                }
                else {
                    deref_args = tokens;
                }
            }
            Err(e) => return Err(e),
        }
    }

    // If the token is a value, apply the modifiers, then
    //      Check if there was an operator found between this and the last value. If not, raise an error.
    // If the token is a modifier, then mark that one was found and push it on.
    // Otherwise, just push it as it is onto the stack.
    for token in deref_args.iter() {
        match token {
            TokenSeparator::Value(data) => {
                match apply_modifiers(&mut modifiers, vm, address, data.to_string()) {
                    Ok(newaddr) => address = Some(newaddr),
                    Err(e) => return Err(e),
                }
                if !operator_found {
                    return Err(InvalidDbgArgError::from(format!(
                        "No operator found between {} and {}.",
                        last_value.expect(""),
                        data
                    )));
                }
                operator_found = false;
                last_value = Some(data.clone());
            }
            TokenSeparator::Offset => {
                operator_found = true;
                modifiers.push(token.clone());
            }
            _ => modifiers.push(token.clone()),
        }
    }

    match address {
        Some(val) => Ok(val),
        None => Err(InvalidDbgArgError::from(
            "Could not discern a value from arguments passed.",
        )),
    }
}

/// Convert a String value into a constructed hex value.
/// E.G., "$808000" becomes 0x808000.
/// Parameters:
///     - `text`:   String to parse.
/// Returns:
///     - `Ok(value)`:  Parsed Hex Value.
///     - `Err(e)`:     If string passed contained data other than a marker and hexa-numeric digits.
fn string_to_hex(text: &str) -> Result<usize, InvalidDbgArgError> {
    let mut value = text.to_string().clone();

    if value.starts_with("$") {
        value = String::from(
            value
                .strip_prefix("$")
                .expect("String did not begin with $"),
        );
    }
    if value.starts_with("0x") {
        value = String::from(
            value
                .strip_prefix("0x")
                .expect("String did not begin with 0x"),
        );
    }

    if value.to_string().is_hex() {
        let mut digits: Vec<u32> = vec![];
        // Construct a list of hex digits for each char.
        for char in value.chars() {
            digits.push(
                char.to_digit(16)
                    .expect("Value was not hex despite checking"),
            );
        }

        let mut hex_value = 0;
        let mut digits_iter = digits.iter();
        for iters in 0..digits.len() {
            hex_value |= (digits_iter.next().expect("Iterated past length of digits"))
                << (((digits.len() - 1) - iters) * 4);
        }
        Ok(hex_value as usize)
    }
    else {
        Err(InvalidDbgArgError::from(format!(
            "Value passed was not a valid hexidecimal number {}",
            value
        )))
    }
}

/**************************************** Public Functions **************************************************************/

/// Parse a list of directives out into a collection of tokens.
/// Parameters:
///     - `&args`:   The input from the user with the command removed and all other values concatenated.
///     - `&debug`:  The debugger with the table of set tags to read.
/// Returns:
///     - `Ok(Vec<TokenSeparator>)`:   List of the arguments the user passed parsed into tokens.
///     - `Err(InvalidDbgArgError)`:
pub fn str_to_args(argvec: &Vec<&str>) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut arg_result: Result<DebugTokenStream, InvalidDbgArgError> =
        Err(InvalidDbgArgError::from("Invalid Arguments"));

    // First Pass: Convert the list of strings into a list of tokens as-is.
    if let Ok(delimiters) = collect_args(argvec.to_vec()) {
        // Second Pass: Convert all of the TokenSeparator::Value()s which correspond to tags into tags
        arg_result = Ok(collect_tags(delimiters));
    }

    return arg_result;
}

/// Take a stream, apply modifiers to the numeric values, and then create a tag.
/// # Parameters:
///     - `&tokens`:     Stream of tokens to parse, where tags have been deref'd where possible.
/// # Returns:
///     - `usize`:      Finalized address of the tag, for immediate use.
pub fn create_new_tag(
    input: &DebugTokenStream, debug: &mut DebuggerState, vm: &VirtualMachine,
) -> Result<usize, InvalidDbgArgError> {
    let result: Result<usize, InvalidDbgArgError>;

    println!("Input to create_new_tag was {:?}", input);

    match validate_tags(input.to_vec(), debug) {
        Ok(mut tokens) => {
            if let Some(TokenSeparator::Tag(ref tagname)) = tokens.pop() {
                // If the length of this is 0, then the parameter was just `tagname`.
                // Make a tag at PC.
                if tokens.len() == 0{
                    debug.tags.insert(tagname.to_string(), vm.cpu.get_pc());
                    println!("Tag {} created at {:#08X}", tagname, vm.cpu.get_pc());
                    result = Ok(vm.cpu.get_pc());
                }
                else {
                    match compute_address_from_args(&tokens, debug, vm) {
                        Ok(value) => {
                            debug.tags.insert(tagname.to_string(), value);
                            println!("Tag {} created at {:#08X}", tagname, value);
                            result = Ok(value);
                        }
                        Err(e) => {
                            result = Err(InvalidDbgArgError::from(format!(
                                "{} Cannot create tag {}.",
                                e, tagname
                            )));
                        }
                    }
                }
            }
            else {
                result = Err(InvalidDbgArgError::from(
                    "Request to create a new tag was formatted incorrectly.",
                ));
            }
        }
        Err(e) => {
            result = Err(e);
        }
    }
    return result;
}

/// Convert arguments as a vector of strings into a computed address value and any tags that match that value, where possible.
/// # Parameters:
///     - `args`:       List of arguments to parse.
///     - `debug`:      Pointer to debugger to read/write tags.
///     - `vm`:         Pointer to virtual machine, to fetch PC from.
/// # Result:
///     - `Ok(Option<Vec<String>>, usize)`: a pair of all the tags that match to value, and a computed address at value.
///     - `Err(InvalidDbgArgError)`:        Any error found while parsing.
pub fn str_to_values(
    args: &Vec<&str>, debug: &DebuggerState, vm: &VirtualMachine,
) -> Result<(Option<Vec<String>>, usize), InvalidDbgArgError> {
    // Initialize the result vars
    let token_args = str_to_args(&args)?;
    let mut cmd_res: Result<(Option<Vec<String>>, usize), InvalidDbgArgError> =
        Err(InvalidDbgArgError::from("Unable to parse arguments"));
    let mut res_tags: Option<Vec<String>> = None;
    let mut res_value: Option<usize> = None;

    match compute_address_from_args(&token_args, debug, vm) {
        Ok(value) => res_value = Some(value),
        Err(e) => cmd_res = Err(e),
    }

    // If there are currently tags set, pass through and see if this value matches any.
    if let Some(tags) = token_args.get_tag_names() {
        res_tags = Some(vec![]);
        for tag in tags {
            res_tags.as_mut().expect("").push(tag.clone());
        }
    }

    if let Some(value) = res_value {
        if let Some(tags) = res_tags {
            cmd_res = Ok((Some(tags.to_vec()), value));
        }
        else {
            cmd_res = Ok((None, value));
        }
    }

    return cmd_res;
}

/**************************************** Tests *************************************************************************/

#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::iter::zip;

    /**************************************** Test Helpers **************************************************************/

    mod testconst {
        use super::*;

        pub const TEST_TAG_NAME: &str = "tagname";
        pub const TEST_TAG_NAME2: &str = "tagname2";
        pub const TEST_TAG_NAME3: &str = "tagname3";
        pub const TEST_BASE_ADDR: &str = "808000";
        pub const TEST_DECIMAL_VALUE: &str = "50";
        pub const _TEST_DECIMAL_VALUE_AS_HEX: &str = "32";
        pub const TEST_HEX_VALUE: &str = "0A";
        pub const TEST_WIDE_HEX_VALUE: &str = "00000A";

        /// Test results for the outcome of each of the tests performed.

        /// The representation of the arguments passed as a vector of strings.

        /// Test cases which are driven purely by numeric literals.
        pub fn token_literal_test_cases() -> Vec<DebugTokenStream> {
            vec![
                // $808000
                // Hex Literal
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // $808000+$0A
                // Hex Literal + Hex Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // $808000+50
                // Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // +$0A
                // PC + Hex Offset
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // +50
                // PC + Decimal Offset
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // 50
                // Decimal Literal
                vec![TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE))],
                // $50
                // Hex Literal (Duplicate, to cover +50, 50, $50 and see all return diff)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // 50+$0A
                // Decimal Literal + Hex Offset
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // 50 + 50
                // Decimal Literal + Decimal Offset
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
            ]
        }

        /// Test cases where the arguments are strings.
        pub fn string_args() -> Vec<Vec<&'static str>> {
            let vec = vec![
                /****** Tag before value ******/
                vec![TEST_TAG_NAME, "$808000"],
                vec![TEST_TAG_NAME, TEST_DECIMAL_VALUE],
                vec![TEST_TAG_NAME, "$808000", "+", "$0A"],
                vec![TEST_TAG_NAME, "$808000", "+", TEST_DECIMAL_VALUE],
                vec![TEST_TAG_NAME, "+", "$0A"],
                vec![TEST_TAG_NAME, "+", TEST_DECIMAL_VALUE],
                /****** Value before tag ******/
                vec!["$808000", TEST_TAG_NAME],
                vec![TEST_DECIMAL_VALUE, TEST_TAG_NAME],
                vec!["$808000", "+", "$0A", TEST_TAG_NAME],
                vec!["$808000", "+", TEST_DECIMAL_VALUE, TEST_TAG_NAME],
                vec!["$0A", "+", TEST_TAG_NAME],
                vec![TEST_DECIMAL_VALUE, "+", TEST_TAG_NAME],
                vec!["+", "$0A", TEST_TAG_NAME],
                vec!["+", TEST_DECIMAL_VALUE, TEST_TAG_NAME],
                /****** Other Combinations ******/
                vec![TEST_TAG_NAME],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2, TEST_TAG_NAME3],
                vec![TEST_TAG_NAME3, TEST_TAG_NAME, "+", TEST_TAG_NAME2],
            ];
            vec
        }

        /// Test cases where a tag is represented as Value(tagname).
        pub fn token_tag_as_value() -> Vec<DebugTokenStream> {
            vec![
                /****** Tag before value ******/
                // tag $808000
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // tag 50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag $808000 + $0A
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag $808000 + 50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag +$0A
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag +50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                /****** Value before tag ******/
                // $808000 tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // 50 tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + $0A tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + 50 tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $0A + tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // 50 + tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // +$0A tag
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // +50 tag
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                /****** Other tag configurations ******/
                // tag
                vec![TokenSeparator::Value(String::from(TEST_TAG_NAME))],
                // tag + tag
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // tag + tag2
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                ],
                // tag1 + tag2 tag3
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag1 + tag2
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME3)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                ],
            ]
        }

        /// Test cases where a tag is represented as Tag(tagname).
        pub fn token_tag_as_tags() -> Vec<DebugTokenStream> {
            vec![
                /******* Value After Tag *******/
                // tag $808000
                // Tag followed by Hex Literal
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // tag 50
                // Tag followed by decimal literal
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag $808000 + $0A
                // Tag, as specified by a hex literal + hex offset
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag $808000 + 50
                // Tag, as specified by a hex literal + decimal offset
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag + $0A
                // Tag with Hex Offset (Tag should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag + 50
                // Tag with Decimal Offset (Tag should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                /******* Value before Tag *******/
                // $808000 tag
                // Hex literal followed by tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // 50 tag
                // Decimal literal followed by tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + $0A tag
                // tag, as defined as Hex literal + Hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + 50 tag
                // tag, as defined as Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $0A + tag
                // Hex literal offset by tag (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // 50 + tag
                // Decimal literal with tag offset (Tag should exist prior)
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // +$0A tag
                // tag as Hex offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // +50 tag
                // tag as decimal offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                /******* Other Tag Cases *******/
                // tag
                // Just a tag name
                vec![TokenSeparator::Tag(String::from(TEST_TAG_NAME))],
                // tag + tag
                // Adding a tag value to itself (should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag + tag2
                // 2 tag values (both should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                ],
                // tag + tag2 tag3
                // 2 tags added = 3rd new tag
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag1 + tag2
                // 2 tags added = 3rd new tag
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                ],
            ]
        }

        /// Test cases where a tag is represented as the value at tagname's address.
        pub fn token_tag_as_deref() -> Vec<DebugTokenStream> {
            vec![
                /******* Value After Tag *******/
                // tag $808000
                // Tag followed by Hex Literal
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // tag 50
                // Tag followed by decimal literal
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag $808000 + $0A
                // Tag, as specified by a hex literal + hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag $808000 + 50
                // Tag, as specified by a hex literal + decimal offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                // tag + $0A
                // Tag with Hex Offset (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                ],
                // tag + 50
                // Tag with Decimal Offset (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                ],
                /******* Value before Tag *******/
                // $808000 tag
                // Hex literal followed by tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // 50 tag
                // Decimal literal followed by tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // $808000 + $0A tag
                // tag, as defined as Hex literal + Hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // $808000 + 50 tag
                // tag, as defined as Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // $0A + tag
                // Hex literal offset by tag (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // 50 + tag
                // Decimal literal with tag offset (Tag should exist prior)
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // +$0A tag
                // tag as Hex offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // +50 tag
                // tag as decimal offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                /******* Other Tag Cases *******/
                // tag
                // Just a tag name
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // tag + tag
                // Adding a tag value to itself (should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                ],
                // tag + tag2
                // 2 tag values (both should exist prior)
                // Hex tag values will always be widened to a 6-digit hex value.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                ],
                // tag + tag2 tag3
                // 2 tag values (both should exist prior) equate to one new tag.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag + tag2
                // 2 tag values (both should exist prior) equate to one new tag.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
            ]
        }
    }

    /**************************************** Unit Test Implementations *************************************************/

    mod debugger_literal_tests {
        use super::testconst::*;
        use super::*;

        #[test]
        fn test_collect_args() {
            let string_vectors: Vec<Vec<&str>> = vec![
                vec!["$808000"],
                vec!["$808000", "+", "$0A"],
                vec!["$808000", "+", TEST_DECIMAL_VALUE],
                vec!["+", "$0A"],
                vec!["+", TEST_DECIMAL_VALUE],
                vec![TEST_DECIMAL_VALUE],
                vec!["$50"],
                vec![TEST_DECIMAL_VALUE, "+", "$0A"],
                vec![TEST_DECIMAL_VALUE, "+", TEST_DECIMAL_VALUE],
            ];
            let token_vectors = token_literal_test_cases();

            for (test_input, expected_result) in zip(string_vectors, token_vectors) {
                assert_eq!(expected_result, collect_args(test_input).unwrap());
            }
        }

        #[test]
        fn test_compute_address_from_args() {
            let test_debug = DebuggerState::new();
            let test_vm = VirtualMachine::new();
            let numeric_result_vector: Vec<usize> = vec![
                0x808000, // $808000
                0x80800A, // $808000+$0A
                0x808032, // $808000+50
                0x80800A, // +$0A
                0x808032, // +50
                0x000032, // 50
                0x000050, // $50
                0x00003C, // 50+$0A
                0x000064, // 50+50
            ];
            let token_vectors = token_literal_test_cases();

            for (test_input, expected_result) in zip(token_vectors, numeric_result_vector) {
                let test_result =
                    compute_address_from_args(&test_input, &test_debug, &test_vm).unwrap();
                println!(
                    "Expected Result was {:#08X} Test Result was {:#08X}",
                    expected_result, test_result
                );
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_apply_modifiers() {
            let test_debug = DebuggerState::new();
            let test_vm = VirtualMachine::new();
            let token_vectors = token_literal_test_cases();
            let numeric_result_vector: Vec<usize> = vec![
                0x808000, // $808000
                0x80800A, // $808000+$0A
                0x808032, // $808000+50
                0x80800A, // +$0A
                0x808032, // +50
                0x000032, // 50
                0x000050, // $50
                0x00003C, // 50+$0A
                0x000064, // 50+50
            ];

            for (test_input, expected_result) in zip(token_vectors, numeric_result_vector) {
                let test_result =
                    compute_address_from_args(&test_input, &test_debug, &test_vm).unwrap();
                println!(
                    "Expected Result was {:#08X} Test Result was {:#08X}",
                    expected_result, test_result
                );
                assert_eq!(expected_result, test_result);
            }
        }
    }

    mod debugger_tag_tests {
        use super::testconst::*;
        use super::*;

        #[test]
        fn test_collect_args() {
            let string_vectors: Vec<Vec<&str>> = string_args();
            let token_vectors = token_tag_as_value();
            for (test_input, expected_result) in zip(string_vectors, token_vectors) {
                let test_result = collect_args(test_input).unwrap();
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_collect_tags() {
            // Get the table of test cases where a tag is represented as TokenSeparator::Value(tagname).
            let test_token_vectors = token_tag_as_value();

            // Get the table of test cases where a tag is represented as a TokenSeparator::Tag(tagname).
            let expected_token_vectors = token_tag_as_tags();

            for (test_input, expected_result) in zip(test_token_vectors, expected_token_vectors) {
                let test_result = collect_tags(test_input);
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_validate_tags() {
            let mut test_debugger = DebuggerState::new();
            test_debugger
                .tags
                .insert(String::from(TEST_TAG_NAME), 0x808000);
            test_debugger
                .tags
                .insert(String::from(TEST_TAG_NAME2), 0x0A);
            let test_tag_tokens = token_tag_as_tags();
            let test_deref_tokens = token_tag_as_deref();

            for (test_input, expected_result) in zip(test_tag_tokens, test_deref_tokens) {
                let test_result = validate_tags(test_input, &test_debugger).unwrap();
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_create_new_tag() {
            let mut debug = DebuggerState::new();
            let vm = VirtualMachine::new();

            let test_tag_tokens = token_tag_as_tags();

            let numeric_results: Vec<Option<usize>> = vec![
                Some(0x808000),     // tag $808000
                Some(50),           // tag 50
                Some(0x80800A),     // tag $808000 + $0A
                Some(0x808032),     // tag $808000 + 50
                None,               // tag +$0A 
                None,               // tag +50

                /* Value before tag */
                Some(0x808000),     // $808000 tag
                Some(50),           // 50 tag
                Some(0x80800A),     // $808000 + $0A tag
                Some(0x808032),     // $808000 + 50 tag
                None, // will fail  // $0A + tag
                None, // will fail  // 50 + tag
                None, // will fail  // +$0A tag
                None, // will fail  // +50 tag
                
                /* Other */
                Some(0x808000),     // tag
                None, // will fail, // tag + tag
                None, // will fail, // tag + tag2
                None, // will fail, // tag + tag2 tag3
                None, // will fail  // tag3 tag + tag2
            ];

            for (test_input, expected_result) in zip(test_tag_tokens, numeric_results) {
                if let Some(expected_result) = expected_result{
                    assert_eq!(expected_result, create_new_tag(&test_input, &mut debug, &vm).unwrap());
                    assert_eq!(expected_result, *debug.tags.get(TEST_TAG_NAME).unwrap());
                    debug.tags.clear();
                }
            }
        }

        #[test]
        fn test_create_new_tag_from_existing() {
            let mut debug = DebuggerState::new();
            let vm = VirtualMachine::new();

            debug.tags.insert(TEST_TAG_NAME.to_string(), 0x808000);
            debug.tags.insert(TEST_TAG_NAME2.to_string(), 0x0A);

            let test_tag_tokens = token_tag_as_tags();

            let numeric_results: Vec<Option<usize>> = vec![
                None,           // tag $808000
                None,           // tag 50
                None,           // tag $808000 + $0A
                None,           // tag $808000 + 50
                None,           // tag +$0A
                None,           // tag +50

                /* Value before tag */
                None,           // $808000 tag
                None,           // 50 tag
                None,           // $808000 + $0A tag
                None,           // $808000 + 50 tag
                None,           // $0A + tag
                None,           // 50 + tag
                None,           // +$0A tag
                None,           // +50 tag
                
                /* Other */
                None,           // tag
                None,           // tag + tag
                None,           // tag + tag2
                Some(0x80800A), // tag + tag2 tag3
                Some(0x80800A), // tag3 tag + tag2
            ];

            for (test_input, expected_result) in zip(test_tag_tokens, numeric_results) {
                if let Some(expected_result) = expected_result{
                    assert_eq!(expected_result, create_new_tag(&test_input, &mut debug, &vm).unwrap());
                    assert_eq!(expected_result, *debug.tags.get(TEST_TAG_NAME3).unwrap());
                    debug.tags.remove(TEST_TAG_NAME3);
                }
            }
        }

        #[test]
        fn test_str_to_args() {
            let string_vectors: Vec<Vec<&str>> = string_args();
            let token_tag_vectors = token_tag_as_tags();

            for (test_input, expected_output) in zip(string_vectors, token_tag_vectors) {
                assert_eq!(expected_output, str_to_args(&test_input).unwrap());
            }
        }

        // #[test]
        // fn test_str_to_values() {}

        // #[test]
        // fn test_compute_address_from_args() {}

        // #[test]
        // fn test_apply_modifiers() {}
    }

    #[test]
    fn test_string_to_hex() {
        // Test 100 Random hex values.
        // We can test across the entire address range, but it does take a lot longer.
        for _step in 0..100 {
            let value: usize = rand::thread_rng().gen_range(0x000000..0xFFFFFF);
            let val_as_string = format!("{:#08X}", value);
            assert_eq!(value, string_to_hex(&val_as_string).unwrap());
        }
    }

    #[test]
    #[should_panic]
    fn test_invalid_string_to_hex() { string_to_hex("$invalid").unwrap(); }
}
